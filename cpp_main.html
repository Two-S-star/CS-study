<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>기술 면접 가이드 - C++</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>

    <nav class="sidebar">
        <h3><a href="index.html">기술 면접 가이드</a></h3>
        <ul>
            <li>
                <h4><a href="cpp_main.html">1. C++</a></h4>
                <ul>
                    <li><strong>1.1. OOP</strong>
                        <ul>
                            <li><a href="cpp_1_1_q1_oop_principles.html">Q: OOP 핵심 원칙</a></li>
                            <li><a href="cpp_1_1_q2_class_object.html">Q: 클래스와 객체</a></li>
                            <li><a href="cpp_1_1_q3_struct_class.html">Q: struct와 class 차이</a></li>
                        </ul>
                    </li>
                    <li><strong>1.2. 포인터와 메모리</strong>
                        <ul>
                            <li><a href="cpp_1_2_q1_pointer_intro.html">Q: C++ 포인터 비유/중요성</a></li>
                            <li><a href="cpp_1_2_q2_memory_areas.html">Q: 메모리 영역</a></li>
                            <li><a href="cpp_1_2_q3_new_malloc.html">Q: new/delete vs malloc/free</a></li>
                            <li><a href="cpp_1_2_q4_smart_pointers.html">Q: 스마트 포인터</a></li>
                            <li><a href="cpp_1_2_q5_memory_problems.html">Q: 메모리 문제점</a></li>
                        </ul>
                    </li>
                    <li><strong>1.3. 가상 함수</strong>
                        <ul>
                            <li><a href="cpp_1_3_q1_virtual_function_vtable.html">Q: 가상 함수/vtable</a></li>
                            <li><a href="cpp_1_3_q2_virtual_call_overhead.html">Q: 가상 함수 오버헤드</a></li>
                            <li><a href="cpp_1_3_q3_virtual_destructor.html">Q: 가상 소멸자</a></li>
                            <li><a href="cpp_1_3_q4_pure_virtual_abstract_class.html">Q: 순수 가상 함수/추상 클래스</a></li>
                        </ul>
                    </li>
                    <li><strong>1.4. const 정확성</strong>
                        <ul>
                            <li><a href="cpp_1_4_q1_const_correctness.html">Q: const 정확성</a></li>
                        </ul>
                    </li>
                    <li><strong>1.5. static 키워드</strong>
                        <ul>
                            <li><a href="cpp_1_5_q1_static_members.html">Q: static 멤버</a></li>
                        </ul>
                    </li>
                    <li><strong>1.6. inline 함수</strong>
                        <ul>
                            <li><a href="cpp_1_6_q1_inline_function.html">Q: inline 함수</a></li>
                        </ul>
                    </li>
                    <li><strong>1.7. volatile 키워드</strong>
                        <ul>
                            <li><a href="cpp_1_7_q1_volatile_keyword.html">Q: volatile 키워드</a></li>
                        </ul>
                    </li>
                    <li><strong>1.8. 모던 C++ 기능</strong>
                        <ul>
                            <li><a href="cpp_1_8_q1_auto_nullptr.html">Q: auto, nullptr</a></li>
                            <li><a href="cpp_1_8_q2_range_based_for.html">Q: 범위 기반 for 루프</a></li>
                            <li><a href="cpp_1_8_q3_lambda_expression.html">Q: 람다 표현식</a></li>
                            <li><a href="cpp_1_8_q4_constexpr.html">Q: constexpr</a></li>
                            <li><a href="cpp_1_8_q5_move_semantics.html">Q: 이동 의미론</a></li>
                        </ul>
                    </li>
                    <li><strong>1.9. STL</strong>
                        <ul>
                            <li><a href="cpp_1_9_q1_stl_containers.html">Q: STL 컨테이너 비교</a></li>
                            <li><a href="cpp_1_9_q2_stl_iterator.html">Q: STL 반복자</a></li>
                            <li><a href="cpp_1_9_q3_vector_vs_list_bullets.html">Q: 총알 관리: vector vs list</a></li>
                        </ul>
                    </li>
                    <li><strong>1.10. 일반적인 함정</strong>
                        <ul>
                            <li><a href="cpp_1_10_q1_common_mistakes.html">Q: C++ 성능 실수</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <h4><a href="dsa_main.html">2. 자료구조 및 알고리즘</a></h4>
                <ul>
                    <li><strong>2.1. 기본 자료구조</strong>
                        <ul>
                            <li><a href="dsa_2_1_q1_array_linkedlist.html">Q: 배열과 연결 리스트</a></li>
                            <li><a href="dsa_2_1_q2_stack_queue.html">Q: 스택과 큐</a></li>
                        </ul>
                    </li>
                    <li><strong>2.2. 트리</strong>
                        <ul>
                            <li><a href="dsa_2_2_q1_binary_tree_bst_traversal.html">Q: 이진 트리, BST, 순회</a></li>
                            <li><a href="dsa_2_2_q2_tree_usage_game.html">Q: 게임에서 트리 사용</a></li>
                        </ul>
                    </li>
                    <li><strong>2.3. 힙</strong>
                        <ul>
                            <li><a href="dsa_2_3_q1_heap_priority_queue.html">Q: 힙과 우선순위 큐</a></li>
                        </ul>
                    </li>
                    <li><strong>2.4. 해시 테이블</strong>
                        <ul>
                            <li><a href="dsa_2_4_q1_hashtable_function_collision.html">Q: 해시 테이블 작동 방식</a></li>
                            <li><a href="dsa_2_4_q2_hashtable_usage_game.html">Q: 게임에서 해시 테이블 사용</a></li>
                        </ul>
                    </li>
                    <li><strong>2.5. 그래프</strong>
                        <ul>
                            <li><a href="dsa_2_5_q1_graph_representation.html">Q: 그래프 표현 방식</a></li>
                            <li><a href="dsa_2_5_q2_bfs_dfs.html">Q: BFS와 DFS</a></li>
                        </ul>
                    </li>
                    <li><strong>2.6. 공간 자료구조</strong>
                        <ul>
                            <li><a href="dsa_2_6_q1_spatial_partitioning_octree.html">Q: 쿼드트리/옥트리</a></li>
                            <li><a href="dsa_2_6_q2_scene_graph.html">Q: 씬 그래프</a></li>
                        </ul>
                    </li>
                    <li><strong>2.7. 일반 알고리즘</strong>
                        <ul>
                            <li><a href="dsa_2_7_q1_sorting_algorithms.html">Q: 정렬 알고리즘</a></li>
                            <li><a href="dsa_2_7_q2_binary_search.html">Q: 이진 탐색</a></li>
                        </ul>
                    </li>
                    <li><strong>2.8. 경로 탐색</strong>
                        <ul>
                            <li><a href="dsa_2_8_q1_a_star.html">Q: A* 알고리즘</a></li>
                        </ul>
                    </li>
                    <li><strong>2.9. 충돌 감지</strong>
                        <ul>
                            <li><a href="dsa_2_9_q1_basic_collision_detection.html">Q: 기본 3D 충돌 감지</a></li>
                        </ul>
                    </li>
                    <li><strong>2.10. 재귀</strong>
                        <ul>
                            <li><a href="dsa_2_10_q1_recursion_game_logic.html">Q: 재귀 이해</a></li>
                        </ul>
                    </li>
                    <li><strong>2.11. 복잡도 분석</strong>
                        <ul>
                            <li><a href="dsa_2_11_q1_big_o_notation.html">Q: 빅오 표기법</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <h4><a href="os_main.html">3. 운영체제 (OS)</a></h4>
                <ul>
                    <li><strong>3.1. 프로세스 대 스레드</strong>
                        <ul>
                            <li><a href="os_3_1_q1_process_vs_thread.html">Q: 프로세스와 스레드 비유/차이</a></li>
                        </ul>
                    </li>
                    <li><strong>3.2. 메모리 관리 (OS 수준)</strong>
                        <ul>
                            <li><a href="os_3_2_q1_virtual_memory.html">Q: 가상 메모리 비유/영향</a></li>
                            <li><a href="os_3_2_q2_memory_fragmentation.html">Q: 메모리 단편화</a></li>
                        </ul>
                    </li>
                    <li><strong>3.3. CPU 스케줄링</strong>
                        <ul>
                            <li><a href="os_3_3_q1_cpu_scheduling_concepts.html">Q: CPU 스케줄링 개념/영향</a></li>
                            <li><a href="os_3_3_q2_dispatch_latency.html">Q: 디스패치 지연 시간</a></li>
                        </ul>
                    </li>
                    <li><strong>3.4. 프로세스 간 통신 (IPC)</strong>
                        <ul>
                            <li><a href="os_3_4_q1_ipc.html">Q: IPC 메커니즘/사용</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <h4><a href="ca_main.html">4. 컴퓨터 구조</a></h4>
                <ul>
                    <li><strong>4.1. CPU</strong>
                        <ul>
                            <li><a href="ca_4_1_q1_cpu_core_clock.html">Q: CPU 코어와 클럭 속도</a></li>
                        </ul>
                    </li>
                    <li><strong>4.2. 메모리 계층 구조</strong>
                        <ul>
                            <li><a href="ca_4_2_q1_memory_hierarchy.html">Q: 메모리 계층 구조 설명</a></li>
                            <li><a href="ca_4_2_q2_cpu_cache_locality_impact.html">Q: CPU 캐시, 데이터 지역성 비유/영향</a></li>
                        </ul>
                    </li>
                    <li><strong>4.3. 데이터 지역성</strong>
                        <ul>
                            <li><a href="ca_4_3_q1_data_locality_types_example.html">Q: 데이터 지역성 정의/예시</a></li>
                        </ul>
                    </li>
                    <li><strong>4.4. CPU 캐시 일관성</strong>
                        <ul>
                            <li><a href="ca_4_4_q1_cache_coherency.html">Q: CPU 캐시 일관성</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </nav>
    <div class="main-content">
        <header>
            <h1>1. C++</h1>
        </header>

        <div class="content-container">
            <p>C++는 게임 엔진 개발 및 고성능 그래픽스 프로그래밍의 핵심 언어입니다. [cite: 4] 메모리 직접 제어, 객체 지향 프로그래밍 지원, 방대한 표준 라이브러리(STL) 제공 등의 특징으로 인해 업계 표준으로 자리매김했습니다. [cite: 5] Unity나 Unreal Engine과 같은 상용 엔진을 사용하더라도, 엔진의 코어 로직을 이해하고 성능을 극한까지 최적화하거나 커스텀 기능을 개발하기 위해서는 C++에 대한 깊이 있는 지식이 필수적입니다. [cite: 6]</p>
            
            <div class="topic-list">
                <h3>1.1. 객체 지향 프로그래밍 (OOP)</h3>
                <a href="cpp_1_1_q1_oop_principles.html" class="topic-list-item">Q: OOP의 핵심 원칙(캡슐화, 추상화, 상속, 다형성)을 설명하고, 각각에 대한 게임 관련 예시를 들어주세요.</a>
                <a href="cpp_1_1_q2_class_object.html" class="topic-list-item">Q: 클래스(Class)와 객체(Object)는 무엇인가요?</a>
                <a href="cpp_1_1_q3_struct_class.html" class="topic-list-item">Q: C++에서 struct와 class의 차이점은 무엇인가요?</a>

                <h3>1.2. 포인터와 메모리 관리</h3>
                <a href="cpp_1_2_q1_pointer_intro.html" class="topic-list-item">Q: C++ 포인터를 게임 개발과 관련된 매우 간단한 실생활 비유로 설명해주세요. 고수준 엔진을 사용하더라도 엔진/그래픽스 프로그래머에게 포인터를 통한 직접적인 메모리 제어가 중요한 이유는 무엇인가요? 포인터는 동적 게임 객체 컬렉션 관리나 하드웨어 인터페이스와 같은 문제를 해결하는 데 어떻게 도움이 되나요?</a>
                <a href="cpp_1_2_q2_memory_areas.html" class="topic-list-item">Q: C++ 프로그램의 여러 메모리 영역(스택, 힘, 데이터, 코드)을 설명해주세요. 지역 변수, 전역 변수, 동적으로 할당된 객체는 어디에 저장되나요?</a>
                <a href="cpp_1_2_q3_new_malloc.html" class="topic-list-item">Q: new/delete와 malloc/free의 차이점은 무엇인가요?</a>
                <a href="cpp_1_2_q4_smart_pointers.html" class="topic-list-item">Q: 스마트 포인터(std::unique_ptr, std::shared_ptr, std::weak_ptr)란 무엇인가요? 메모리 누수를 방지하는 데 어떻게 도움이 되나요? 게임 관련 예시를 들어주세요.</a>
                <a href="cpp_1_2_q5_memory_problems.html" class="topic-list-item">Q: C++ 게임 개발에서 흔히 발생하는 메모리 관련 문제점(누수, 댕글링 포인터, 단편화)은 무엇인가요? 이러한 문제들이 게임 성능과 안정성에 어떤 영향을 미치나요?</a>

                <h3>1.3. 가상 함수 (Virtual Functions)</h3>
                <a href="cpp_1_3_q1_virtual_function_vtable.html" class="topic-list-item">Q: 가상 함수란 무엇인가요? 다형성을 어떻게 가능하게 하나요? 가상 테이블(vtable)의 개념을 설명해주세요.</a>
                <a href="cpp_1_3_q2_virtual_call_overhead.html" class="topic-list-item">Q: 가상 함수 호출의 성능 오버헤드는 무엇인가요? 게임 개발에서 언제 허용될 수 있나요?</a>
                <a href="cpp_1_3_q3_virtual_destructor.html" class="topic-list-item">Q: 소멸자(destructor)는 언제 가상(virtual)이어야 하나요?</a>
                <a href="cpp_1_3_q4_pure_virtual_abstract_class.html" class="topic-list-item">Q: 순수 가상 함수(pure virtual function)란 무엇인가요? 추상 클래스(abstract class)란 무엇인가요?</a>
                
                <h3>1.4. const 정확성 (Const Correctness)</h3>
                <a href="cpp_1_4_q1_const_correctness.html" class="topic-list-item">Q: const 정확성이란 무엇인가요? C++에서 왜 중요한가요? const 멤버 함수와 const 매개변수의 예를 들어주세요.</a>

                <h3>1.5. static 키워드</h3>
                <a href="cpp_1_5_q1_static_members.html" class="topic-list-item">Q: static 데이터 멤버와 static 멤버 함수는 무엇인가요? 비정적(non-static) 멤버와 어떻게 다른가요?</a>

                <h3>1.6. inline 함수</h3>
                <a href="cpp_1_6_q1_inline_function.html" class="topic-list-item">Q: inline 함수란 무엇인가요? 목적은 무엇이며, 컴파일러가 이를 무시할 수 있는 경우는 언제인가요?</a>

                <h3>1.7. volatile 키워드</h3>
                <a href="cpp_1_7_q1_volatile_keyword.html" class="topic-list-item">Q: volatile 키워드는 무엇을 의미하나요? 게임 개발에서 언제 사용할 수 있나요 (예: 멀티스레딩, 하드웨어 레지스터)?</a>

                <h3>1.8. 모던 C++ 기능 (C++11 이후)</h3>
                <a href="cpp_1_8_q1_auto_nullptr.html" class="topic-list-item">Q: auto와 nullptr에 대해 설명해주세요.</a>
                <a href="cpp_1_8_q2_range_based_for.html" class="topic-list-item">Q: 범위 기반 for 루프(range-based for loop)란 무엇인가요? 반복을 어떻게 단순화하나요?</a>
                <a href="cpp_1_8_q3_lambda_expression.html" class="topic-list-item">Q: 람다 표현식(lambda expression)이란 무엇인가요? 간단한 게임 관련 예시를 들어주세요 (예: 정렬 조건자, 콜백 함수).</a>
                <a href="cpp_1_8_q4_constexpr.html" class="topic-list-item">Q: C++ constexpr을 간단한 실생활 비유로 설명해주세요. 컴파일 시간에 수행될 수 있는 계산(예: 게임 설정 상수, 물리/그래픽용 조회 테이블 생성)에 대한 런타임 오버헤드 문제를 어떻게 해결하나요? 이것이 엔진/그래픽스 프로그래머에게 핵심 최적화 도구인 이유는 무엇인가요?</a>
                <a href="cpp_1_8_q5_move_semantics.html" class="topic-list-item">Q: C++ 이동 의미론(rvalue 참조, std::move)을 간단한 실생활 비유로 설명해주세요. 함수에서 큰 게임 객체(예: 메시 또는 레벨 데이터 벡터)를 반환하거나 컨테이너에 저장할 때 발생하는 비싼 깊은 복사 문제를 어떻게 해결하여 게임 성능을 향상시키나요? 이것이 엔진 프로그래머에게 필수적인 이유는 무엇인가요?</a>

                <h3>1.9. 표준 템플릿 라이브러리 (STL)</h3>
                <a href="cpp_1_9_q1_stl_containers.html" class="topic-list-item">Q: std::vector, std::list, std::map/std::unordered_map과 같은 일반적인 STL 컨테이너를 설명해주세요. 이들의 성능 특성(삽입, 삭제, 접근, 반복)과 게임 개발에서의 일반적인 사용 사례는 무엇인가요?</a>
                <a href="cpp_1_9_q2_stl_iterator.html" class="topic-list-item">Q: STL에서 반복자(iterator)란 무엇인가요?</a>
                <a href="cpp_1_9_q3_vector_vs_list_bullets.html" class="topic-list-item">Q: 게임 시나리오: 수천 개의 총알 관리. std::vector와 std::list를 비교해주세요. std::vector의 캐시 친화성(cache friendliness)이 여기서 std::list에 비해 성능 문제를 어떻게 해결하나요? 이 선택이 게임 루프를 최적화하는 엔진/그래픽스 프로그래머에게 왜 중요한가요?</a>
                
                <h3>1.10. C++ 게임 개발에서의 일반적인 함정</h3>
                <a href="cpp_1_10_q1_common_mistakes.html" class="topic-list-item">Q: 게임에서 흔히 발생하는 C++ 성능 관련 실수(STL 오용, 메모리 오류, 문자열 처리)와 이것이 게임 FPS나 안정성에 미치는 직접적인 영향을 초보자를 위해 설명해주세요. 이를 이해하는 것이 엔진/그래픽스 프로그래머가 더 나은 코드를 작성하는 데 어떻게 도움이 되나요?</a>
            </div>

            <h2>C++ 섹션 심층 분석 및 테이블</h2>
            <p>PDF의 "C++ 섹션 심층 분석" 내용과 "표 1: 게임 개발에서의 C++ STL 컨테이너 비교"는 이 페이지의 하단이나 별도의 상세 페이지로 추가할 수 있습니다. 여기서는 주요 질문 목록을 제공합니다.</p>
            </div>

        <footer>
            <p>&copy; 2025 기술 면접 가이드 (최종 수정일: 2025년 5월 14일)</p>
        </footer>
    </div>

</body>
</html>