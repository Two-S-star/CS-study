<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++: OOP 핵심 원칙</title> {/* 각 페이지 주제에 맞게 title 수정 */}
    <link rel="stylesheet" href="styles.css">
</head>
<body>

    <nav class="sidebar">
        <h3><a href="index.html">기술 면접 가이드</a></h3>
        <ul>
            <li>
                <h4><a href="cpp_main.html">1. C++</a></h4>
                <ul>
                    <li><strong>1.1. OOP</strong>
                        <ul>
                            <li><a href="cpp_1_1_q1_oop_principles.html">Q: OOP 핵심 원칙</a></li>
                            <li><a href="cpp_1_1_q2_class_object.html">Q: 클래스와 객체</a></li>
                            <li><a href="cpp_1_1_q3_struct_class.html">Q: struct와 class 차이</a></li>
                        </ul>
                    </li>
                    <li><strong>1.2. 포인터와 메모리</strong>
                        <ul>
                            <li><a href="cpp_1_2_q1_pointer_intro.html">Q: C++ 포인터 비유/중요성</a></li>
                            <li><a href="cpp_1_2_q2_memory_areas.html">Q: 메모리 영역</a></li>
                            <li><a href="cpp_1_2_q3_new_malloc.html">Q: new/delete vs malloc/free</a></li>
                            <li><a href="cpp_1_2_q4_smart_pointers.html">Q: 스마트 포인터</a></li>
                            <li><a href="cpp_1_2_q5_memory_problems.html">Q: 메모리 문제점</a></li>
                        </ul>
                    </li>
                    <li><strong>1.3. 가상 함수</strong>
                        <ul>
                            <li><a href="cpp_1_3_q1_virtual_function_vtable.html">Q: 가상 함수/vtable</a></li>
                            <li><a href="cpp_1_3_q2_virtual_call_overhead.html">Q: 가상 함수 오버헤드</a></li>
                            <li><a href="cpp_1_3_q3_virtual_destructor.html">Q: 가상 소멸자</a></li>
                            <li><a href="cpp_1_3_q4_pure_virtual_abstract_class.html">Q: 순수 가상 함수/추상 클래스</a></li>
                        </ul>
                    </li>
                    <li><strong>1.4. const 정확성</strong>
                        <ul>
                            <li><a href="cpp_1_4_q1_const_correctness.html">Q: const 정확성</a></li>
                        </ul>
                    </li>
                    <li><strong>1.5. static 키워드</strong>
                        <ul>
                            <li><a href="cpp_1_5_q1_static_members.html">Q: static 멤버</a></li>
                        </ul>
                    </li>
                    <li><strong>1.6. inline 함수</strong>
                        <ul>
                            <li><a href="cpp_1_6_q1_inline_function.html">Q: inline 함수</a></li>
                        </ul>
                    </li>
                    <li><strong>1.7. volatile 키워드</strong>
                        <ul>
                            <li><a href="cpp_1_7_q1_volatile_keyword.html">Q: volatile 키워드</a></li>
                        </ul>
                    </li>
                    <li><strong>1.8. 모던 C++ 기능</strong>
                        <ul>
                            <li><a href="cpp_1_8_q1_auto_nullptr.html">Q: auto, nullptr</a></li>
                            <li><a href="cpp_1_8_q2_range_based_for.html">Q: 범위 기반 for 루프</a></li>
                            <li><a href="cpp_1_8_q3_lambda_expression.html">Q: 람다 표현식</a></li>
                            <li><a href="cpp_1_8_q4_constexpr.html">Q: constexpr</a></li>
                            <li><a href="cpp_1_8_q5_move_semantics.html">Q: 이동 의미론</a></li>
                        </ul>
                    </li>
                    <li><strong>1.9. STL</strong>
                        <ul>
                            <li><a href="cpp_1_9_q1_stl_containers.html">Q: STL 컨테이너 비교</a></li>
                            <li><a href="cpp_1_9_q2_stl_iterator.html">Q: STL 반복자</a></li>
                            <li><a href="cpp_1_9_q3_vector_vs_list_bullets.html">Q: 총알 관리: vector vs list</a></li>
                        </ul>
                    </li>
                    <li><strong>1.10. 일반적인 함정</strong>
                        <ul>
                            <li><a href="cpp_1_10_q1_common_mistakes.html">Q: C++ 성능 실수</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <h4><a href="dsa_main.html">2. 자료구조 및 알고리즘</a></h4>
                <ul>
                    <li><strong>2.1. 기본 자료구조</strong>
                        <ul>
                            <li><a href="dsa_2_1_q1_array_linkedlist.html">Q: 배열과 연결 리스트</a></li>
                            <li><a href="dsa_2_1_q2_stack_queue.html">Q: 스택과 큐</a></li>
                        </ul>
                    </li>
                    <li><strong>2.2. 트리</strong>
                        <ul>
                            <li><a href="dsa_2_2_q1_binary_tree_bst_traversal.html">Q: 이진 트리, BST, 순회</a></li>
                            <li><a href="dsa_2_2_q2_tree_usage_game.html">Q: 게임에서 트리 사용</a></li>
                        </ul>
                    </li>
                    <li><strong>2.3. 힙</strong>
                        <ul>
                            <li><a href="dsa_2_3_q1_heap_priority_queue.html">Q: 힙과 우선순위 큐</a></li>
                        </ul>
                    </li>
                    <li><strong>2.4. 해시 테이블</strong>
                        <ul>
                            <li><a href="dsa_2_4_q1_hashtable_function_collision.html">Q: 해시 테이블 작동 방식</a></li>
                            <li><a href="dsa_2_4_q2_hashtable_usage_game.html">Q: 게임에서 해시 테이블 사용</a></li>
                        </ul>
                    </li>
                    <li><strong>2.5. 그래프</strong>
                        <ul>
                            <li><a href="dsa_2_5_q1_graph_representation.html">Q: 그래프 표현 방식</a></li>
                            <li><a href="dsa_2_5_q2_bfs_dfs.html">Q: BFS와 DFS</a></li>
                        </ul>
                    </li>
                    <li><strong>2.6. 공간 자료구조</strong>
                        <ul>
                            <li><a href="dsa_2_6_q1_spatial_partitioning_octree.html">Q: 쿼드트리/옥트리</a></li>
                            <li><a href="dsa_2_6_q2_scene_graph.html">Q: 씬 그래프</a></li>
                        </ul>
                    </li>
                    <li><strong>2.7. 일반 알고리즘</strong>
                        <ul>
                            <li><a href="dsa_2_7_q1_sorting_algorithms.html">Q: 정렬 알고리즘</a></li>
                            <li><a href="dsa_2_7_q2_binary_search.html">Q: 이진 탐색</a></li>
                        </ul>
                    </li>
                    <li><strong>2.8. 경로 탐색</strong>
                        <ul>
                            <li><a href="dsa_2_8_q1_a_star.html">Q: A* 알고리즘</a></li>
                        </ul>
                    </li>
                    <li><strong>2.9. 충돌 감지</strong>
                        <ul>
                            <li><a href="dsa_2_9_q1_basic_collision_detection.html">Q: 기본 3D 충돌 감지</a></li>
                        </ul>
                    </li>
                    <li><strong>2.10. 재귀</strong>
                        <ul>
                            <li><a href="dsa_2_10_q1_recursion_game_logic.html">Q: 재귀 이해</a></li>
                        </ul>
                    </li>
                    <li><strong>2.11. 복잡도 분석</strong>
                        <ul>
                            <li><a href="dsa_2_11_q1_big_o_notation.html">Q: 빅오 표기법</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <h4><a href="os_main.html">3. 운영체제 (OS)</a></h4>
                <ul>
                    <li><strong>3.1. 프로세스 대 스레드</strong>
                        <ul>
                            <li><a href="os_3_1_q1_process_vs_thread.html">Q: 프로세스와 스레드 비유/차이</a></li>
                        </ul>
                    </li>
                    <li><strong>3.2. 메모리 관리 (OS 수준)</strong>
                        <ul>
                            <li><a href="os_3_2_q1_virtual_memory.html">Q: 가상 메모리 비유/영향</a></li>
                            <li><a href="os_3_2_q2_memory_fragmentation.html">Q: 메모리 단편화</a></li>
                        </ul>
                    </li>
                    <li><strong>3.3. CPU 스케줄링</strong>
                        <ul>
                            <li><a href="os_3_3_q1_cpu_scheduling_concepts.html">Q: CPU 스케줄링 개념/영향</a></li>
                            <li><a href="os_3_3_q2_dispatch_latency.html">Q: 디스패치 지연 시간</a></li>
                        </ul>
                    </li>
                    <li><strong>3.4. 프로세스 간 통신 (IPC)</strong>
                        <ul>
                            <li><a href="os_3_4_q1_ipc.html">Q: IPC 메커니즘/사용</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <h4><a href="ca_main.html">4. 컴퓨터 구조</a></h4>
                <ul>
                    <li><strong>4.1. CPU</strong>
                        <ul>
                            <li><a href="ca_4_1_q1_cpu_core_clock.html">Q: CPU 코어와 클럭 속도</a></li>
                        </ul>
                    </li>
                    <li><strong>4.2. 메모리 계층 구조</strong>
                        <ul>
                            <li><a href="ca_4_2_q1_memory_hierarchy.html">Q: 메모리 계층 구조 설명</a></li>
                            <li><a href="ca_4_2_q2_cpu_cache_locality_impact.html">Q: CPU 캐시, 데이터 지역성 비유/영향</a></li>
                        </ul>
                    </li>
                    <li><strong>4.3. 데이터 지역성</strong>
                        <ul>
                            <li><a href="ca_4_3_q1_data_locality_types_example.html">Q: 데이터 지역성 정의/예시</a></li>
                        </ul>
                    </li>
                    <li><strong>4.4. CPU 캐시 일관성</strong>
                        <ul>
                            <li><a href="ca_4_4_q1_cache_coherency.html">Q: CPU 캐시 일관성</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </nav>
    <div class="main-content">
        <header>
            <h1>C++: OOP의 핵심 원칙</h1>
        </header>

        <div class="content-container">
            <h2>Q: OOP의 핵심 원칙(캡슐화, 추상화, 상속, 다형성)을 설명하고, 각각에 대한 게임 관련 예시를 들어주세요.</h2>
            
            <p>OOP는 복잡한 게임 시스템을 보다 체계적이고 유연하게 설계할 수 있도록 돕는 프로그래밍 패러다임입니다. [cite: 7]</p>

            <h4>캡슐화 (Encapsulation)</h4>
            <p>데이터(속성)와 해당 데이터에 작용하는 함수(메소드)를 하나의 단위(클래스)로 묶고, 내부 구현을 외부로부터 숨기는 것입니다. [cite: 9] 이는 데이터의 무결성을 보호하고, 객체 사용 방식을 단순화합니다. [cite: 10]</p>
            <p><strong>게임 예시:</strong> Player 클래스는 플레이어의 체력(health), 위치(position)와 같은 데이터를 멤버 변수로 가지고, takeDamage(), move()와 같은 메소드를 통해 이 데이터에 접근하고 조작합니다. [cite: 10] 외부에서는 이 메소드를 통해서만 Player 객체의 상태를 변경할 수 있으며, health 변수에 직접 음수 값을 할당하는 등의 오류를 방지할 수 있습니다. [cite: 11]</p>

            <h4>추상화 (Abstraction)</h4>
            <p>복잡한 내부 구현은 숨기고, 사용자에게는 필수적인 기능만을 인터페이스로 제공하는 것입니다. [cite: 12]</p>
            <p><strong>게임 예시:</strong> Renderer 클래스는 draw(GameObject)라는 메소드를 제공할 수 있습니다. [cite: 13] 게임 로직을 작성하는 프로그래머는 Renderer가 내부적으로 어떤 복잡한 과정을 거쳐 화면에 오브젝트를 그리는지 알 필요 없이, 단순히 draw 메소드 호출만으로 렌더링 기능을 사용할 수 있습니다. [cite: 13, 14]</p>

            <h4>상속 (Inheritance)</h4>
            <p>기존 클래스(부모 클래스)의 속성과 메소드를 물려받아 새로운 클래스(자식 클래스)를 만드는 것입니다. [cite: 14] 코드 재사용성을 높이고 클래스 간의 계층 구조를 형성합니다. [cite: 15]</p>
            <p><strong>게임 예시:</strong> FlyingEnemy 클래스가 일반적인 Enemy 클래스로부터 상속받는 경우, FlyingEnemy는 Enemy의 기본 속성(체력, 공격력 등)과 행동(플레이어 감지 등)을 물려받으면서, 자신만의 고유한 비행 로직을 추가할 수 있습니다. [cite: 15]</p>

            <h4>다형성 (Polymorphism)</h4>
            <p>"여러 가지 형태를 가질 수 있는 능력"을 의미합니다. [cite: 15] 주로 부모 클래스 타입의 포인터나 참조를 통해 자식 클래스 객체를 다루면서, 동일한 함수 호출에 대해 각 객체의 실제 타입에 맞는 행동을 하도록 하는 것입니다. [cite: 16] 가상 함수(virtual function)를 통해 구현됩니다. [cite: 17]</p>
            <p><strong>게임 예시:</strong> GameObject* 타입의 리스트에 Player, Enemy, Obstacle 등 다양한 게임 오브젝트의 포인터를 저장하고, 각 오브젝트에 대해 가상 함수 update()를 호출하면, 실제로는 Player의 update(), Enemy의 update() 등 각 타입에 맞게 재정의된 update() 함수가 실행됩니다. [cite: 17]</p>
        </div>

        <footer>
            <p>&copy; 2025 기술 면접 가이드 (최종 수정일: 2025년 5월 14일)</p>
        </footer>
    </div>

</body>
</html>